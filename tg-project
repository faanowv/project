#!/usr/bin/env python3
"""
üîê Telegram Bot: –ê–Ω–∞–ª–∏–∑–∞—Ç–æ—Ä –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–æ–≤
–ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è —Å–æ –≤—Å–µ–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∞–º–∏ –∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π –ª–æ–≥–∏–∫–æ–π –∞–Ω–∞–ª–∏–∑–∞
"""

import asyncio
import logging
from datetime import datetime
from typing import Dict, List, Optional
import time

# –û—Å–Ω–æ–≤–Ω—ã–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
import requests
from bs4 import BeautifulSoup
import tldextract
import dns.resolver
import socket
import ssl
from urllib.parse import urlparse
import re
import warnings

# –ë–∏–±–ª–∏–æ—Ç–µ–∫–∏ –¥–ª—è Telegram
from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    filters
)

warnings.filterwarnings('ignore')

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
URL_INPUT, MENU, RESULTS, DETAILS, RECOMMENDATIONS = range(5)


class SecurityAnalyzerBot:
    """–û—Å–Ω–æ–≤–Ω–æ–π –∫–ª–∞—Å—Å –±–æ—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–æ–≤"""

    def __init__(self, token: str):
        self.token = token
        self.timeout = 10  # –£–≤–µ–ª–∏—á–∏–ª —Ç–∞–π–º–∞—É—Ç
        self.user_data = {}
        self.whitelist = {
            'google.com', 'youtube.com', 'facebook.com', 'amazon.com', 'wikipedia.org',
            'twitter.com', 'github.com', 'stackoverflow.com', 'reddit.com', 'netflix.com',
            'yandex.ru', 'vk.com', 'mail.ru', 'ok.ru', 'microsoft.com', 'apple.com'
        }
        self.suspicious_tlds = ['.tk', '.ml', '.ga', '.cf', '.gq', '.xyz', '.top', '.club', '.pw', '.icu']

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        user = update.effective_user

        welcome_text = (
            f"üëã –ü—Ä–∏–≤–µ—Ç, {user.first_name}!\n\n"
            "üîê *–Ø - –±–æ—Ç –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤–µ–±-—Å–∞–π—Ç–æ–≤*\n\n"
            "‚ú® *–ß—Ç–æ —è —É–º–µ—é:*\n"
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—è—Ç—å SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç—ã\n"
            "‚Ä¢ –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–æ–º–µ–Ω–Ω—ã–µ –∏–º–µ–Ω–∞\n"
            "‚Ä¢ –û–±–Ω–∞—Ä—É–∂–∏–≤–∞—Ç—å —Ñ–∏—à–∏–Ω–≥\n"
            "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—è—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
            "‚Ä¢ –û—Ü–µ–Ω–∏–≤–∞—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å\n"
            "‚Ä¢ –î–∞–≤–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n\n"
            "üìù *–ö–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å:*\n"
            "1. –ù–∞–∂–º–∏—Ç–µ 'üîç –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∞–π—Ç'\n"
            "2. –û—Ç–ø—Ä–∞–≤—å—Ç–µ URL —Å–∞–π—Ç–∞\n"
            "3. –ü–æ–ª—É—á–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç\n\n"
            "‚ö†Ô∏è *–í–Ω–∏–º–∞–Ω–∏–µ:* –ë–æ—Ç –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –æ–±—Ä–∞–∑–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–µ–ª–µ–π!"
        )

        keyboard = [
            [InlineKeyboardButton("üîç –ê–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∞–π—Ç", callback_data="analyze")],
            [InlineKeyboardButton("üìä –ü—Ä–∏–º–µ—Ä –æ—Ç—á–µ—Ç–∞", callback_data="example")],
            [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="help")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        if update.callback_query:
            await update.callback_query.edit_message_text(
                welcome_text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
            await update.callback_query.answer()
        else:
            await update.message.reply_text(
                welcome_text,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

        return MENU

    async def menu_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞–∂–∞—Ç–∏–π –∫–Ω–æ–ø–æ–∫ –º–µ–Ω—é"""
        query = update.callback_query
        await query.answer()

        if query.data == "analyze":
            await query.edit_message_text(
                "üåê *–í–≤–µ–¥–∏—Ç–µ URL —Å–∞–π—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:*\n\n"
                "–ü—Ä–∏–º–µ—Ä—ã:\n"
                "‚Ä¢ https://google.com\n"
                "‚Ä¢ youtube.com\n"
                "‚Ä¢ wikipedia.org\n\n"
                "–ù–∞–ø–∏—à–∏—Ç–µ URL –≤ —á–∞—Ç:",
                parse_mode='Markdown'
            )
            return URL_INPUT

        elif query.data == "example":
            await self.show_example(query)
        elif query.data == "help":
            await self.show_help(query)
        elif query.data == "back_to_menu":
            await self.start(update, context)

        return MENU

    async def show_example(self, query):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–∏–º–µ—Ä –æ—Ç—á–µ—Ç–∞"""
        example_report = (
            "üìã *–ü–†–ò–ú–ï–† –û–¢–ß–ï–¢–ê*\n\n"
            "üåê –°–∞–π—Ç: https://google.com\n"
            "‚è∞ –í—Ä–µ–º—è: 2024-01-15 14:30:00\n\n"
            "üîç *–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–æ–≤–µ—Ä–∫–∏:*\n\n"
            "‚úÖ *–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å:* –û—Ç–ª–∏—á–Ω–æ (10/10)\n"
            "   –°–∞–π—Ç –¥–æ—Å—Ç—É–ø–µ–Ω –∑–∞ 0.15 —Å–µ–∫—É–Ω–¥\n\n"
            "‚úÖ *HTTPS:* –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è (10/10)\n"
            "   –ó–∞—â–∏—â–µ–Ω–Ω—ã–π –ø—Ä–æ—Ç–æ–∫–æ–ª\n\n"
            "‚úÖ *SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç:* –î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω (10/10)\n"
            "   –î–µ–π—Å—Ç–≤—É–µ—Ç –µ—â–µ 365 –¥–Ω–µ–π\n\n"
            "‚ö†Ô∏è  *–ó–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:* –°—Ä–µ–¥–Ω–∏–µ (7/10)\n"
            "   –ù–∞–π–¥–µ–Ω–æ 3 –∏–∑ 4 –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤\n\n"
            "‚úÖ *–î–æ–º–µ–Ω:* –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π (12/15)\n"
            "   –õ–µ–≥–∏—Ç–∏–º–Ω—ã–π –¥–æ–º–µ–Ω\n\n"
            "‚úÖ *–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:* –û—Ç–ª–∏—á–Ω–æ (9/10)\n"
            "   –ó–∞–≥—Ä—É–∑–∫–∞: 0.8—Å, –†–∞–∑–º–µ—Ä: 45KB\n\n"
            "üèÜ *–ò–¢–û–ì–û–í–ê–Ø –û–¶–ï–ù–ö–ê:* 92/100\n"
            "üìä *–£–†–û–í–ï–ù–¨ –†–ò–°–ö–ê:* –û–ß–ï–ù–¨ –ù–ò–ó–ö–ò–ô\n\n"
            "üí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n"
            "‚Ä¢ –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"
        )

        keyboard = [[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            example_report,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

    async def show_help(self, query):
        """–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–º–æ—â—å"""
        help_text = (
            "‚ùì *–ü–û–ú–û–©–¨ –ò –ò–ù–°–¢–†–£–ö–¶–ò–ò*\n\n"
            "üîç *–ö–∞–∫ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å–∞–π—Ç—ã:*\n"
            "1. –û—Ç–ø—Ä–∞–≤—å—Ç–µ URL —Å–∞–π—Ç–∞\n"
            "2. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∞–ª–∏–∑–∞\n"
            "3. –ü–æ–ª—É—á–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á–µ—Ç\n\n"
            "üìä *–ß—Ç–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è:*\n"
            "‚Ä¢ –ù–∞–ª–∏—á–∏–µ HTTPS\n"
            "‚Ä¢ –í–∞–ª–∏–¥–Ω–æ—Å—Ç—å SSL-—Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞\n"
            "‚Ä¢ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ HTTP-–∑–∞–≥–æ–ª–æ–≤–∫–∏\n"
            "‚Ä¢ –î–æ–º–µ–Ω–Ω–æ–µ –∏–º—è (—Ñ–∏—à–∏–Ω–≥-–ø—Ä–æ–≤–µ—Ä–∫–∞)\n"
            "‚Ä¢ –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞\n"
            "‚Ä¢ DNS –∑–∞–ø–∏—Å–∏\n"
            "‚Ä¢ –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n\n"
            "‚ö†Ô∏è *–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è:*\n"
            "‚Ä¢ –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –∞–Ω–∞–ª–∏–∑–∞: 30 —Å–µ–∫\n"
            "‚Ä¢ –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Å–∞–π—Ç—ã –º–æ–≥—É—Ç –±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∑–∞–ø—Ä–æ—Å—ã\n"
            "‚Ä¢ –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ—Ç–æ—á–Ω—ã–º–∏ –¥–ª—è –æ—á–µ–Ω—å —Å–ª–æ–∂–Ω—ã—Ö —Å–∞–π—Ç–æ–≤\n\n"
            "üìû *–ü–æ–¥–¥–µ—Ä–∂–∫–∞:*\n"
            "–î–ª—è –≤–æ–ø—Ä–æ—Å–æ–≤ –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π —Å–≤—è–∂–∏—Ç–µ—Å—å —Å —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–æ–º"
        )

        keyboard = [[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            help_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

    async def analyze_url(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–µ–¥–µ–Ω–Ω–æ–≥–æ URL"""
        url = update.message.text.strip()

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º URL –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ
        context.user_data['url'] = url

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å "–ø–µ—á–∞—Ç–∞–µ—Ç"
        await context.bot.send_chat_action(
            chat_id=update.effective_chat.id,
            action="typing"
        )

        # –ù–∞—á–∏–Ω–∞–µ–º –∞–Ω–∞–ª–∏–∑
        message = await update.message.reply_text(
            f"üîç *–ù–∞—á–∏–Ω–∞—é –∞–Ω–∞–ª–∏–∑:* {url}\n\n"
            "‚è≥ –í—ã–ø–æ–ª–Ω—è—é –ø—Ä–æ–≤–µ—Ä–∫–∏...",
            parse_mode='Markdown'
        )

        try:
            # –í—ã–ø–æ–ª–Ω—è–µ–º –∞–Ω–∞–ª–∏–∑
            results = await self.perform_full_analysis(url)

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            context.user_data['last_results'] = results
            context.user_data['summary_message_id'] = message.message_id

            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            await self.send_summary(update, context, results, message.message_id)

            return RESULTS

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ: {e}")
            await update.message.reply_text(
                f"‚ùå *–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ*\n\n"
                f"–ü—Ä–∏—á–∏–Ω–∞: {str(e)[:100]}\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–π —Å–∞–π—Ç –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å URL.",
                parse_mode='Markdown'
            )

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –≤ –º–µ–Ω—é
            keyboard = [[InlineKeyboardButton("üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", callback_data="back_to_menu")]]
            reply_markup = InlineKeyboardMarkup(keyboard)

            await update.message.reply_text(
                "–ß—Ç–æ –¥–∞–ª—å—à–µ?",
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

            return MENU

    async def perform_full_analysis(self, url: str) -> Dict:
        """–í—ã–ø–æ–ª–Ω–∏—Ç—å –ø–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ —Å–∞–π—Ç–∞"""
        parsed_url = self.normalize_url(url)
        if not parsed_url:
            raise ValueError("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π URL")

        domain = urlparse(parsed_url).netloc

        checks = []

        # 1. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
        availability = self.check_availability(parsed_url)
        checks.append({'category': 'security', 'name': '–î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–∞–π—Ç–∞', **availability})

        # 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ HTTPS
        https_check = self.check_https(parsed_url)
        checks.append({'category': 'security', 'name': 'HTTPS –ø—Ä–æ—Ç–æ–∫–æ–ª', **https_check})

        # 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ SSL (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ HTTPS)
        if https_check['score'] > 0:
            ssl_check = self.check_ssl_certificate(parsed_url)
            checks.append({'category': 'security', 'name': 'SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç', **ssl_check})

        # 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        if availability['score'] > 0:
            headers_check = self.check_security_headers(parsed_url)
            checks.append({'category': 'security', 'name': '–ó–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏', **headers_check})

            # 5. –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
            performance_check = self.check_performance(parsed_url)
            checks.append({'category': 'performance', 'name': '–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å', **performance_check})

            # 6. –ê–Ω–∞–ª–∏–∑ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
            content_info = self.analyze_content(parsed_url)
            checks.append({'category': 'quality', 'name': '–ê–Ω–∞–ª–∏–∑ –∫–æ–Ω—Ç–µ–Ω—Ç–∞', **content_info})

            # 7. –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞
            content_security = self.check_content_security(parsed_url)
            checks.append({'category': 'security', 'name': '–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞', **content_security})

            # 8. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–∞–π—Ç–∞
            structure_check = self.check_site_structure(parsed_url)
            checks.append({'category': 'quality', 'name': '–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Å–∞–π—Ç–∞', **structure_check})

        # 9. –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ–º–µ–Ω–∞
        domain_check = self.check_domain_security(domain)
        checks.append({'category': 'authenticity', 'name': '–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –¥–æ–º–µ–Ω–∞', **domain_check})

        # 10. –ü—Ä–æ–≤–µ—Ä–∫–∞ DNS
        dns_check = self.check_dns_records(domain)
        checks.append({'category': 'security', 'name': 'DNS –∑–∞–ø–∏—Å–∏', **dns_check})

        # 11. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ–∏—à–∏–Ω–≥
        phishing_check = self.check_for_phishing(domain)
        checks.append({'category': 'authenticity', 'name': '–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ–∏—à–∏–Ω–≥', **phishing_check})

        # 12. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–¥–∏—Ä–µ–∫—Ç–æ–≤
        redirect_check = self.check_redirects(parsed_url)
        checks.append({'category': 'security', 'name': 'HTTP —Ä–µ–¥–∏—Ä–µ–∫—Ç—ã', **redirect_check})

        # –†–∞—Å—á–µ—Ç –∏—Ç–æ–≥–æ–≤–æ–π –æ—Ü–µ–Ω–∫–∏
        total_score = sum(c.get('score', 0) for c in checks)
        total_max = sum(c.get('max_score', 0) for c in checks)

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –æ—Ü–µ–Ω–∫—É –∫ 100 –±–∞–ª–ª–∞–º
        safety_score = int((total_score / total_max) * 100) if total_max > 0 else 0

        return {
            'url': url,
            'parsed_url': parsed_url,
            'domain': domain,
            'timestamp': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'checks': checks,
            'total_score': safety_score,
            'raw_score': total_score,
            'max_score': total_max
        }

    def normalize_url(self, url: str) -> Optional[str]:
        """–ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è URL"""
        url = url.strip()

        # –£–±–∏—Ä–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–µ –ø—Ä–æ–±–µ–ª—ã –∏ –ª–∏—à–Ω–∏–µ —Å–∏–º–≤–æ–ª—ã
        url = re.sub(r'\s+', '', url)

        # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–æ—Ç–æ–∫–æ–ª –µ—Å–ª–∏ –Ω–µ—Ç
        if not url.startswith(('http://', 'https://')):
            url = 'https://' + url

        try:
            parsed = urlparse(url)
            if not parsed.netloc:
                return None

            domain = parsed.netloc.lower()
            # –£–±–∏—Ä–∞–µ–º www
            if domain.startswith('www.'):
                domain = domain[4:]

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Å https –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            return f"https://{domain}"
        except:
            return None

    def check_availability(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ —Å–∞–π—Ç–∞"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'ru-RU,ru;q=0.9,en-US;q=0.8,en;q=0.7',
                'Accept-Encoding': 'gzip, deflate',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1'
            }

            start_time = time.time()
            response = requests.get(
                url,
                headers=headers,
                timeout=self.timeout,
                allow_redirects=True,
                verify=True  # –í–∫–ª—é—á–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É SSL
            )
            response_time = time.time() - start_time

            if response.status_code == 200:
                if response_time < 1.0:
                    return {'score': 10, 'max_score': 10, 'status': '‚úÖ –û—Ç–ª–∏—á–Ω–æ',
                            'details': f'–î–æ—Å—Ç—É–ø–µ–Ω –∑–∞ {response_time:.2f} —Å–µ–∫—É–Ω–¥ (–∫–æ–¥ 200)'}
                elif response_time < 3.0:
                    return {'score': 8, 'max_score': 10, 'status': '‚úÖ –•–æ—Ä–æ—à–æ',
                            'details': f'–î–æ—Å—Ç—É–ø–µ–Ω –∑–∞ {response_time:.2f} —Å–µ–∫—É–Ω–¥ (–∫–æ–¥ 200)'}
                else:
                    return {'score': 6, 'max_score': 10, 'status': '‚ö†Ô∏è –ú–µ–¥–ª–µ–Ω–Ω–æ',
                            'details': f'–î–æ—Å—Ç—É–ø–µ–Ω –∑–∞ {response_time:.2f} —Å–µ–∫—É–Ω–¥ (–∫–æ–¥ 200)'}
            elif response.status_code in [301, 302, 307, 308]:
                return {'score': 7, 'max_score': 10, 'status': '‚ö†Ô∏è –†–µ–¥–∏—Ä–µ–∫—Ç',
                        'details': f'–†–µ–¥–∏—Ä–µ–∫—Ç (–∫–æ–¥ {response.status_code})'}
            else:
                return {'score': 4, 'max_score': 10, 'status': '‚ö†Ô∏è –ü—Ä–æ–±–ª–µ–º—ã',
                        'details': f'–ö–æ–¥ –æ—Ç–≤–µ—Ç–∞: {response.status_code}'}

        except requests.exceptions.Timeout:
            return {'score': 0, 'max_score': 10, 'status': '‚ùå –¢–∞–π–º–∞—É—Ç',
                    'details': '–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è (10 —Å–µ–∫)'}
        except requests.exceptions.SSLError:
            # –ü—Ä–æ–±—É–µ–º —á–µ—Ä–µ–∑ HTTP
            try:
                http_url = url.replace('https://', 'http://')
                response = requests.get(http_url, timeout=5, allow_redirects=False)
                return {'score': 3, 'max_score': 10, 'status': '‚ö†Ô∏è –ë–µ–∑ SSL',
                        'details': '–î–æ—Å—Ç—É–ø–µ–Ω –ø–æ HTTP, –Ω–æ HTTPS –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç'}
            except:
                return {'score': 2, 'max_score': 10, 'status': '‚ö†Ô∏è –û—à–∏–±–∫–∞ SSL',
                        'details': '–ü—Ä–æ–±–ª–µ–º—ã —Å SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–º'}
        except requests.exceptions.ConnectionError:
            return {'score': 1, 'max_score': 10, 'status': '‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω',
                    'details': '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ —Å–µ—Ä–≤–µ—Ä—É'}
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_availability: {e}")
            return {'score': 2, 'max_score': 10, 'status': '‚ö†Ô∏è –û—à–∏–±–∫–∞',
                    'details': f'–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {str(e)[:50]}'}

    def check_https(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è HTTPS"""
        try:
            parsed = urlparse(url)
            if parsed.scheme == 'https':
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ HTTPS –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–±–æ—Ç–∞–µ—Ç
                try:
                    response = requests.head(url, timeout=5, verify=True)
                    if response.status_code in [200, 301, 302, 307, 308]:
                        return {'score': 10, 'max_score': 10, 'status': '‚úÖ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è',
                                'details': '–°–∞–π—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∑–∞—â–∏—â–µ–Ω–Ω—ã–π HTTPS –ø—Ä–æ—Ç–æ–∫–æ–ª'}
                    else:
                        return {'score': 7, 'max_score': 10, 'status': '‚ö†Ô∏è HTTPS —Å –æ—à–∏–±–∫–æ–π',
                                'details': f'HTTPS —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –∫–æ–¥: {response.status_code}'}
                except:
                    return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è HTTPS –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç',
                            'details': 'HTTPS –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç'}
            else:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ HTTPS –≤–µ—Ä—Å–∏—è
                https_url = url.replace('http://', 'https://')
                try:
                    response = requests.head(https_url, timeout=5, allow_redirects=False)
                    if response.status_code in [200, 301, 302]:
                        return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è –î–æ—Å—Ç—É–ø–µ–Ω HTTPS',
                                'details': 'HTTPS –¥–æ—Å—Ç—É–ø–µ–Ω, –Ω–æ —Å–∞–π—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç HTTP'}
                except:
                    pass

                return {'score': 0, 'max_score': 10, 'status': '‚ùå HTTP',
                        'details': '–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–µ–∑–∞—â–∏—â–µ–Ω–Ω—ã–π HTTP –ø—Ä–æ—Ç–æ–∫–æ–ª'}
        except:
            return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø—Ä–æ—Ç–æ–∫–æ–ª'}

    def check_ssl_certificate(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–∞"""
        try:
            parsed = urlparse(url)
            hostname = parsed.netloc

            # –£–±–∏—Ä–∞–µ–º –ø–æ—Ä—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
            if ':' in hostname:
                hostname = hostname.split(':')[0]

            context = ssl.create_default_context()
            context.check_hostname = True
            context.verify_mode = ssl.CERT_REQUIRED

            with socket.create_connection((hostname, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è
                    if 'notAfter' in cert:
                        not_after = cert['notAfter']
                        try:
                            # –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã –¥–∞—Ç
                            date_formats = [
                                '%b %d %H:%M:%S %Y %Z',
                                '%Y%m%d%H%M%SZ',
                                '%Y-%m-%d %H:%M:%S'
                            ]

                            cert_date = None
                            for fmt in date_formats:
                                try:
                                    cert_date = datetime.strptime(not_after, fmt)
                                    break
                                except:
                                    continue

                            if cert_date:
                                days_left = (cert_date - datetime.now()).days

                                if days_left > 90:
                                    return {'score': 10, 'max_score': 10, 'status': '‚úÖ –î–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω',
                                            'details': f'SSL –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –µ—â–µ {days_left} –¥–Ω–µ–π'}
                                elif days_left > 30:
                                    return {'score': 8, 'max_score': 10, 'status': '‚úÖ –•–æ—Ä–æ—à–∏–π',
                                            'details': f'SSL –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω –µ—â–µ {days_left} –¥–Ω–µ–π'}
                                elif days_left > 0:
                                    return {'score': 4, 'max_score': 10, 'status': '‚ö†Ô∏è –°–∫–æ—Ä–æ –∏—Å—Ç–µ—á–µ—Ç',
                                            'details': f'SSL –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ {days_left} –¥–Ω–µ–π'}
                                else:
                                    return {'score': 0, 'max_score': 10, 'status': '‚ùå –ü—Ä–æ—Å—Ä–æ—á–µ–Ω',
                                            'details': 'SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –ø—Ä–æ—Å—Ä–æ—á–µ–Ω'}
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–∞—Ç—ã SSL: {e}")

                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–¥–∞—Ç–µ–ª—è
                    if 'issuer' in cert:
                        issuer = str(cert['issuer'])
                        if 'Let\'s Encrypt' in issuer:
                            return {'score': 9, 'max_score': 10, 'status': '‚úÖ Let\'s Encrypt',
                                    'details': 'SSL –æ—Ç Let\'s Encrypt (–±–µ—Å–ø–ª–∞—Ç–Ω—ã–π)'}
                        elif 'Cloudflare' in issuer:
                            return {'score': 10, 'max_score': 10, 'status': '‚úÖ Cloudflare',
                                    'details': 'SSL –æ—Ç Cloudflare'}
                        elif 'Google' in issuer or 'GTS' in issuer:
                            return {'score': 10, 'max_score': 10, 'status': '‚úÖ Google',
                                    'details': 'SSL –æ—Ç Google Trust Services'}

                    return {'score': 8, 'max_score': 10, 'status': '‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω',
                            'details': 'SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∏ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω'}

        except ssl.SSLCertVerificationError as e:
            return {'score': 2, 'max_score': 10, 'status': '‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏',
                    'details': f'–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ SSL: {str(e.reason)}'}
        except socket.timeout:
            return {'score': 3, 'max_score': 10, 'status': '‚ö†Ô∏è –¢–∞–π–º–∞—É—Ç',
                    'details': '–¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ SSL'}
        except ConnectionRefusedError:
            return {'score': 2, 'max_score': 10, 'status': '‚ùå –ü–æ—Ä—Ç –∑–∞–∫—Ä—ã—Ç',
                    'details': '–ü–æ—Ä—Ç 443 –∑–∞–∫—Ä—ã—Ç –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'}
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_ssl_certificate: {e}")
            return {'score': 3, 'max_score': 10, 'status': '‚ö†Ô∏è –û—à–∏–±–∫–∞',
                    'details': f'–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å SSL: {str(e)[:50]}'}

    def check_security_headers(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            response = requests.head(url, headers=headers, timeout=5, allow_redirects=True)
            response_headers = response.headers

            security_headers = [
                ('Strict-Transport-Security', 'HSTS (–∑–∞—â–∏—Ç–∞ –æ—Ç downgrade –∞—Ç–∞–∫)'),
                ('X-Frame-Options', '–ó–∞—â–∏—Ç–∞ –æ—Ç clickjacking'),
                ('X-Content-Type-Options', '–ó–∞–ø—Ä–µ—Ç MIME-sniffing'),
                ('X-XSS-Protection', '–ó–∞—â–∏—Ç–∞ –æ—Ç XSS'),
                ('Content-Security-Policy', '–ü–æ–ª–∏—Ç–∏–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞'),
                ('Referrer-Policy', '–ö–æ–Ω—Ç—Ä–æ–ª—å —Ä–µ—Ñ–µ—Ä–µ—Ä–∞'),
                ('Permissions-Policy', '–ü–æ–ª–∏—Ç–∏–∫–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–π')
            ]

            found_headers = []
            details_list = []

            for header, description in security_headers:
                if header in response_headers:
                    found_headers.append(header)
                    value = response_headers[header][:50]
                    details_list.append(f"‚Ä¢ {header}: {value}")

            score = min(len(found_headers) * 2, 10)  # –ú–∞–∫—Å–∏–º—É–º 10 –±–∞–ª–ª–æ–≤

            if score >= 8:
                status = '‚úÖ –û—Ç–ª–∏—á–Ω—ã–µ'
            elif score >= 5:
                status = '‚ö†Ô∏è –°—Ä–µ–¥–Ω–∏–µ'
            elif score >= 2:
                status = '‚ùå –°–ª–∞–±—ã–µ'
            else:
                status = '‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç'

            details = f'–ù–∞–π–¥–µ–Ω–æ {len(found_headers)} –∏–∑ {len(security_headers)} –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤'
            if details_list:
                details += '\n' + '\n'.join(details_list[:3])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 3

            return {'score': score, 'max_score': 10, 'status': status,
                    'details': details}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_security_headers: {e}")
            return {'score': 0, 'max_score': 10, 'status': '‚ö†Ô∏è –û—à–∏–±–∫–∞',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–∫–∏'}

    def check_domain_security(self, domain: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –¥–æ–º–µ–Ω–∞"""
        try:
            extracted = tldextract.extract(domain)
            base_domain = f"{extracted.domain}.{extracted.suffix}"

            score = 15  # –ù–∞—á–∞–ª—å–Ω—ã–π –±–∞–ª–ª
            details = []

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –±–µ–ª—ã–π —Å–ø–∏—Å–æ–∫
            if base_domain in self.whitelist:
                return {'score': 15, 'max_score': 15, 'status': '‚úÖ –õ–µ–≥–∏—Ç–∏–º–Ω—ã–π',
                        'details': '–î–æ–º–µ–Ω –≤ —Å–ø–∏—Å–∫–µ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —Å–∞–π—Ç–æ–≤'}

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ TLD
            tld = '.' + extracted.suffix
            if tld in self.suspicious_tlds:
                score -= 5
                details.append(f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π TLD: {tld}")
            elif tld in ['.com', '.org', '.net', '.edu', '.gov']:
                score += 2
                details.append(f"‚Ä¢ –ù–∞–¥–µ–∂–Ω—ã–π TLD: {tld}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã –¥–æ–º–µ–Ω–∞
            domain_length = len(extracted.domain)
            if domain_length > 20:
                score -= 2
                details.append(f"‚Ä¢ –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ –∏–º—è: {domain_length} —Å–∏–º–≤–æ–ª–æ–≤")
            elif domain_length < 3:
                score -= 3
                details.append(f"‚Ä¢ –°–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ –∏–º—è: {domain_length} —Å–∏–º–≤–æ–ª–∞")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ–∏—à–∏–Ω–≥-—Å–ª–æ–≤–∞
            phishing_words = ['login', 'secure', 'verify', 'account', 'bank', 'pay', 'update', 'service']
            domain_lower = domain.lower()
            found_phishing_words = []

            for word in phishing_words:
                if word in domain_lower:
                    found_phishing_words.append(word)

            if found_phishing_words:
                score -= len(found_phishing_words) * 1
                details.append(f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ —Å–ª–æ–≤–∞: {', '.join(found_phishing_words)}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —á–∏—Å–ª–∞ –≤ –¥–æ–º–µ–Ω–µ (–∫—Ä–æ–º–µ –Ω–æ—Ä–º–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞–µ–≤)
            if re.search(r'\d{4,}', extracted.domain):  # 4+ —Ü–∏—Ñ—Ä –ø–æ–¥—Ä—è–¥
                score -= 2
                details.append("‚Ä¢ –ú–Ω–æ–≥–æ —Ü–∏—Ñ—Ä –≤ –∏–º–µ–Ω–∏ (–ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–æ)")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–µ—Ñ–∏—Å–æ–≤
            hyphen_count = extracted.domain.count('-')
            if hyphen_count >= 3:
                score -= 2
                details.append(f"‚Ä¢ –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –¥–µ—Ñ–∏—Å–æ–≤: {hyphen_count}")

            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –±–∞–ª–ª—ã
            score = max(0, min(score, 15))

            if score >= 12:
                status = '‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π'
            elif score >= 8:
                status = '‚ö†Ô∏è –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π'
            else:
                status = '‚ùå –û–ø–∞—Å–Ω—ã–π'

            details_text = '–ê–Ω–∞–ª–∏–∑ –¥–æ–º–µ–Ω–Ω–æ–≥–æ –∏–º–µ–Ω–∏'
            if details:
                details_text += '\n' + '\n'.join(details[:4])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ 4 –ø—É–Ω–∫—Ç–∞

            return {'score': score, 'max_score': 15, 'status': status,
                    'details': details_text}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_domain_security: {e}")
            return {'score': 8, 'max_score': 15, 'status': '‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –¥–æ–º–µ–Ω'}

    def check_performance(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Accept-Encoding': 'gzip, deflate'
            }

            start_time = time.time()
            response = requests.get(url, headers=headers, timeout=self.timeout, stream=True)

            # –ß–∏—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–µ—Ä–≤—ã–µ 50KB –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
            content = b''
            for chunk in response.iter_content(chunk_size=8192):
                content += chunk
                if len(content) > 51200:  # 50KB
                    break

            load_time = time.time() - start_time
            page_size_kb = len(content) / 1024

            # –û—Ü–µ–Ω–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –∑–∞–≥—Ä—É–∑–∫–∏
            time_score = 0
            if load_time < 0.5:
                time_score = 5
                time_status = '–æ—á–µ–Ω—å –±—ã—Å—Ç—Ä–æ'
            elif load_time < 1.0:
                time_score = 4
                time_status = '–±—ã—Å—Ç—Ä–æ'
            elif load_time < 2.0:
                time_score = 3
                time_status = '—Å—Ä–µ–¥–Ω–µ'
            elif load_time < 3.0:
                time_score = 2
                time_status = '–º–µ–¥–ª–µ–Ω–Ω–æ'
            else:
                time_score = 1
                time_status = '–æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ'

            # –û—Ü–µ–Ω–∫–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É
            size_score = 0
            if page_size_kb < 100:
                size_score = 5
                size_status = '–æ—Ç–ª–∏—á–Ω—ã–π'
            elif page_size_kb < 500:
                size_score = 4
                size_status = '—Ö–æ—Ä–æ—à–∏–π'
            elif page_size_kb < 2000:
                size_score = 3
                size_status = '–±–æ–ª—å—à–æ–π'
            elif page_size_kb < 5000:
                size_score = 2
                size_status = '–æ—á–µ–Ω—å –±–æ–ª—å—à–æ–π'
            else:
                size_score = 1
                size_status = '–æ–≥—Ä–æ–º–Ω—ã–π'

            total_score = time_score + size_score

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–∂–∞—Ç–∏—è
            encoding = response.headers.get('Content-Encoding', '').lower()
            if 'gzip' in encoding or 'br' in encoding or 'deflate' in encoding:
                compression = '–¥–∞'
                total_score += 1
            else:
                compression = '–Ω–µ—Ç'
                total_score -= 1

            # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –±–∞–ª–ª
            total_score = max(1, min(total_score, 10))

            details = (f'–ó–∞–≥—Ä—É–∑–∫–∞: {load_time:.2f}—Å ({time_status}), '
                       f'–†–∞–∑–º–µ—Ä: {page_size_kb:.0f}KB ({size_status}), '
                       f'–°–∂–∞—Ç–∏–µ: {compression}')

            if total_score >= 8:
                status = '‚úÖ –û—Ç–ª–∏—á–Ω–∞—è'
            elif total_score >= 6:
                status = '‚ö†Ô∏è –•–æ—Ä–æ—à–∞—è'
            elif total_score >= 4:
                status = '‚ö†Ô∏è –°—Ä–µ–¥–Ω—è—è'
            else:
                status = '‚ùå –ü–ª–æ—Ö–∞—è'

            return {'score': total_score, 'max_score': 10, 'status': status,
                    'details': details}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_performance: {e}")
            return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –∏–∑–º–µ—Ä–∏—Ç—å –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å'}

    def analyze_content(self, url: str) -> Dict:
        """–ê–Ω–∞–ª–∏–∑ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ —Å–∞–π—Ç–∞"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            response = requests.get(url, headers=headers, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')

            # –ù–∞—Ö–æ–¥–∏–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
            title_tag = soup.find('title')
            title = title_tag.get_text(strip=True) if title_tag else '–ù–µ —É–∫–∞–∑–∞–Ω'

            # –ù–∞—Ö–æ–¥–∏–º –æ–ø–∏—Å–∞–Ω–∏–µ
            meta_desc = soup.find('meta', attrs={'name': 'description'})
            description = ''
            if meta_desc and meta_desc.get('content'):
                desc = meta_desc['content'].strip()
                description = desc[:120] + '...' if len(desc) > 120 else desc
            else:
                # –ò—â–µ–º –ø–µ—Ä–≤—ã–π –∞–±–∑–∞—Ü
                first_p = soup.find('p')
                if first_p:
                    desc = first_p.get_text(strip=True)
                    description = desc[:120] + '...' if len(desc) > 120 else desc
                else:
                    description = '–ù–µ —É–∫–∞–∑–∞–Ω–æ'

            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø —Å–∞–π—Ç–∞
            text = soup.get_text().lower()[:2000]
            site_type = '–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π'

            keywords = {
                '–∏–Ω—Ç–µ—Ä–Ω–µ—Ç-–º–∞–≥–∞–∑–∏–Ω': ['–∫—É–ø–∏—Ç—å', '—Ü–µ–Ω–∞', '—Ä—É–±–ª—å', '–∫–æ—Ä–∑–∏–Ω–∞', '–¥–æ—Å—Ç–∞–≤–∫–∞', '–æ–ø–ª–∞—Ç–∞', '—Ç–æ–≤–∞—Ä'],
                '–Ω–æ–≤–æ—Å—Ç–Ω–æ–π': ['–Ω–æ–≤–æ—Å—Ç—å', '–Ω–æ–≤–æ—Å—Ç–∏', '—Ä–µ–ø–æ—Ä—Ç–∞–∂', '—Å–º–∏', '–∂—É—Ä–Ω–∞–ª–∏—Å—Ç', '—Ä–µ–¥–∞–∫—Ü–∏—è'],
                '–±–ª–æ–≥': ['–±–ª–æ–≥', '–ø–æ—Å—Ç', '–∑–∞–ø–∏—Å—å', '–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π', '–∞–≤—Ç–æ—Ä', '–ø—É–±–ª–∏–∫–∞—Ü–∏—è'],
                '—Ñ–æ—Ä—É–º': ['—Ñ–æ—Ä—É–º', '–æ–±—Å—É–∂–¥–µ–Ω–∏–µ', '—Ç–µ–º–∞', '—Å–æ–æ–±—â–µ–Ω–∏–µ', '–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å'],
                '–∫–æ—Ä–ø–æ—Ä–∞—Ç–∏–≤–Ω—ã–π': ['–∫–æ–º–ø–∞–Ω–∏—è', '–æ –Ω–∞—Å', '–∫–æ–Ω—Ç–∞–∫—Ç—ã', '—É—Å–ª—É–≥–∏', '–ø—Ä–æ–¥—É–∫—Ü–∏—è']
            }

            max_matches = 0
            for type_name, words in keywords.items():
                matches = sum(1 for word in words if word in text)
                if matches > max_matches:
                    max_matches = matches
                    site_type = type_name

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤–∞–∂–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
            score = 8  # –ë–∞–∑–æ–≤—ã–π –±–∞–ª–ª
            details_parts = [f"–¢–∏–ø: {site_type}"]

            if title and title != '–ù–µ —É–∫–∞–∑–∞–Ω':
                details_parts.append(f"–ó–∞–≥–æ–ª–æ–≤–æ–∫: {title[:40]}...")
                score += 1

            if description and description != '–ù–µ —É–∫–∞–∑–∞–Ω–æ':
                details_parts.append(f"–û–ø–∏—Å–∞–Ω–∏–µ: {description[:40]}...")
                score += 1

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ viewport (–¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
            viewport = soup.find('meta', attrs={'name': 'viewport'})
            if viewport:
                details_parts.append("–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–π –¥–∏–∑–∞–π–Ω: –¥–∞")
                score += 1

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ favicon
            favicon = soup.find('link', rel='icon') or soup.find('link', rel='shortcut icon')
            if favicon:
                details_parts.append("Favicon: –µ—Å—Ç—å")
                score += 1

            score = max(5, min(score, 10))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º 5-10

            details = ', '.join(details_parts[:3])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ 3 –ø—É–Ω–∫—Ç–∞

            return {'score': score, 'max_score': 10, 'status': '‚úÖ –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω',
                    'details': details}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ analyze_content: {e}")
            return {'score': 6, 'max_score': 10, 'status': '‚ö†Ô∏è –ß–∞—Å—Ç–∏—á–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç'}

    def check_content_security(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            response = requests.get(url, headers=headers, timeout=self.timeout)
            content = response.text.lower()

            score = 10  # –ù–∞—á–∞–ª—å–Ω—ã–π –±–∞–ª–ª
            warnings_list = []

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–∫—Ä—ã—Ç—ã–µ iframe
            iframe_count = content.count('<iframe')
            if iframe_count > 10:
                score -= 3
                warnings_list.append(f"‚Ä¢ –ú–Ω–æ–≥–æ iframe: {iframe_count}")
            elif iframe_count > 5:
                score -= 1
                warnings_list.append(f"‚Ä¢ –ù–µ—Å–∫–æ–ª—å–∫–æ iframe: {iframe_count}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–µ —Å–∫—Ä–∏–ø—Ç—ã
            suspicious_patterns = [
                ('eval(', 'eval() —Ñ—É–Ω–∫—Ü–∏—è'),
                ('document.write', '–ø—Ä—è–º–∞—è –∑–∞–ø–∏—Å—å –≤ –¥–æ–∫—É–º–µ–Ω—Ç'),
                ('fromcharcode', 'fromCharCode'),
                ('settimeout', 'setTimeout —Å —Å—Ç—Ä–æ–∫–æ–π'),
                ('setinterval', 'setInterval —Å —Å—Ç—Ä–æ–∫–æ–π'),
                ('innerhtml', 'innerHTML —Å –≤–Ω–µ—à–Ω–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏')
            ]

            found_patterns = []
            for pattern, description in suspicious_patterns:
                if pattern in content:
                    found_patterns.append(description)

            if found_patterns:
                score -= min(len(found_patterns), 3)
                warnings_list.append(f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π –∫–æ–¥: {', '.join(found_patterns[:2])}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤–Ω–µ—à–Ω–∏–µ —Ä–µ—Å—É—Ä—Å—ã
            external_scripts = content.count('src="http') - content.count('src="' + url)
            if external_scripts > 20:
                score -= 2
                warnings_list.append(f"‚Ä¢ –ú–Ω–æ–≥–æ –≤–Ω–µ—à–Ω–∏—Ö —Å–∫—Ä–∏–ø—Ç–æ–≤: {external_scripts}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –º–∏–Ω–∏—Ñ–∏–∫–∞—Ü–∏—é (–æ–±—ã—á–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ)
            if 'function(' in content and 'var ' in content:
                # –ù–µ –º–∏–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥
                pass
            elif len(content) > 100000 and 'function(' not in content:
                # –í–æ–∑–º–æ–∂–Ω–æ –º–∏–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–ª–∏ –æ–±—Ñ—É—Å—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
                score -= 1
                warnings_list.append("‚Ä¢ –í–æ–∑–º–æ–∂–Ω–æ –æ–±—Ñ—É—Å—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥")

            score = max(3, min(score, 10))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º 3-10

            if score >= 8:
                status = '‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π'
            elif score >= 6:
                status = '‚ö†Ô∏è –ù–æ—Ä–º–∞–ª—å–Ω—ã–π'
            else:
                status = '‚ùå –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π'

            details = '–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å'
            if warnings_list:
                details += '\n' + '\n'.join(warnings_list[:3])

            return {'score': score, 'max_score': 10, 'status': status,
                    'details': details}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_content_security: {e}")
            return {'score': 7, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç–∞'}

    def check_dns_records(self, domain: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ DNS –∑–∞–ø–∏—Å–µ–π"""
        try:
            # –£–±–∏—Ä–∞–µ–º –ø–æ—Ä—Ç –µ—Å–ª–∏ –µ—Å—Ç—å
            if ':' in domain:
                domain = domain.split(':')[0]

            details = []

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ A –∑–∞–ø–∏—Å–µ–π
            try:
                answers_a = dns.resolver.resolve(domain, 'A')
                a_count = len(answers_a)
                details.append(f"‚Ä¢ A –∑–∞–ø–∏—Å–µ–π: {a_count}")

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ Cloudflare
                for answer in answers_a:
                    ip = str(answer)
                    if ip.startswith('104.') or ip.startswith('172.') or ip.startswith('173.'):
                        details.append(f"‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç Cloudflare")
                        break

            except (dns.resolver.NoAnswer, dns.resolver.NXDOMAIN):
                details.append("‚Ä¢ A –∑–∞–ø–∏—Å–µ–π: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ MX –∑–∞–ø–∏—Å–µ–π (–ø–æ—á—Ç–∞)
            try:
                answers_mx = dns.resolver.resolve(domain, 'MX')
                mx_count = len(answers_mx)
                details.append(f"‚Ä¢ MX –∑–∞–ø–∏—Å–µ–π: {mx_count}")
            except:
                details.append("‚Ä¢ MX –∑–∞–ø–∏—Å–µ–π: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ TXT –∑–∞–ø–∏—Å–µ–π
            try:
                answers_txt = dns.resolver.resolve(domain, 'TXT')
                has_spf = any('spf' in str(txt).lower() for txt in answers_txt)
                has_dmarc = any('dmarc' in str(txt).lower() for txt in answers_txt)

                if has_spf:
                    details.append("‚Ä¢ SPF: –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
                else:
                    details.append("‚Ä¢ SPF: –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω")

                if has_dmarc:
                    details.append("‚Ä¢ DMARC: –Ω–∞—Å—Ç—Ä–æ–µ–Ω")
            except:
                details.append("‚Ä¢ TXT –∑–∞–ø–∏—Å–µ–π: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            # –û—Ü–µ–Ω–∫–∞
            score = 8  # –ë–∞–∑–æ–≤—ã–π –±–∞–ª–ª

            if 'A –∑–∞–ø–∏—Å–µ–π: –Ω–µ –Ω–∞–π–¥–µ–Ω–æ' in details[0]:
                score = 0
                status = '‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω'
            elif 'SPF: –Ω–∞—Å—Ç—Ä–æ–µ–Ω' in details and 'MX –∑–∞–ø–∏—Å–µ–π:' in details[1]:
                score = 10
                status = '‚úÖ –û—Ç–ª–∏—á–Ω—ã–µ'
            else:
                if 'SPF: –Ω–∞—Å—Ç—Ä–æ–µ–Ω' in details:
                    score += 1
                if 'MX –∑–∞–ø–∏—Å–µ–π:' in details[1] and '–Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ' not in details[1]:
                    score += 1
                status = '‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω—ã'

            details_text = '\n'.join(details[:5])

            return {'score': min(score, 10), 'max_score': 10, 'status': status,
                    'details': details_text}

        except dns.resolver.NXDOMAIN:
            return {'score': 0, 'max_score': 10, 'status': '‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω',
                    'details': '–î–æ–º–µ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –≤ DNS'}
        except dns.resolver.NoNameservers:
            return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è –û—à–∏–±–∫–∞ NS',
                    'details': '–ü—Ä–æ–±–ª–µ–º—ã —Å DNS —Å–µ—Ä–≤–µ—Ä–∞–º–∏'}
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_dns_records: {e}")
            return {'score': 6, 'max_score': 10, 'status': '‚ö†Ô∏è –ß–∞—Å—Ç–∏—á–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≤—Å–µ DNS –∑–∞–ø–∏—Å–∏'}

    def check_for_phishing(self, domain: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ñ–∏—à–∏–Ω–≥"""
        try:
            extracted = tldextract.extract(domain)

            score = 10  # –ù–∞—á–∞–ª—å–Ω—ã–π –±–∞–ª–ª
            warnings = []

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ TLD
            tld = '.' + extracted.suffix
            if tld in self.suspicious_tlds:
                score -= 4
                warnings.append(f"‚Ä¢ –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π TLD: {tld}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ —Ñ–∏—à–∏–Ω–≥–∞
            phishing_keywords = [
                ('login', '–ª–æ–≥–∏–Ω'),
                ('secure', '–±–µ–∑–æ–ø–∞—Å–Ω'),
                ('verify', '–ø–æ–¥—Ç–≤–µ—Ä–∂–¥'),
                ('account', '–∞–∫–∫–∞—É–Ω—Ç'),
                ('bank', '–±–∞–Ω–∫'),
                ('pay', '–ø–ª–∞—Ç'),
                ('update', '–æ–±–Ω–æ–≤'),
                ('service', '—Å–µ—Ä–≤–∏—Å'),
                ('signin', '–≤—Ö–æ–¥'),
                ('auth', '–∞—É—Ç–µ–Ω—Ç–∏—Ñ')
            ]

            domain_lower = domain.lower()
            found_keywords = []

            for eng, rus in phishing_keywords:
                if eng in domain_lower or rus in domain_lower:
                    found_keywords.append(eng)

            if found_keywords:
                score -= min(len(found_keywords) * 2, 6)
                warnings.append(f"‚Ä¢ –ö–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ —Ñ–∏—à–∏–Ω–≥–∞: {', '.join(found_keywords[:3])}")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª–∏–Ω—ã –¥–æ–º–µ–Ω–∞
            if len(domain) > 35:
                score -= 1
                warnings.append(f"‚Ä¢ –°–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω—ã–π –¥–æ–º–µ–Ω: {len(domain)} —Å–∏–º–≤–æ–ª–æ–≤")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–¥–æ–º–µ–Ω—ã
            if extracted.subdomain:
                subdomain_parts = extracted.subdomain.split('.')
                if len(subdomain_parts) > 2:
                    score -= 1
                    warnings.append(f"‚Ä¢ –°–ª–æ–∂–Ω—ã–π –ø–æ–¥–¥–æ–º–µ–Ω: {extracted.subdomain}")

                # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø–æ–¥–º–µ–Ω—É –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –±—Ä–µ–Ω–¥–æ–≤ –≤ –ø–æ–¥–¥–æ–º–µ–Ω–∞—Ö
                brands = ['google', 'facebook', 'microsoft', 'apple', 'paypal', 'yandex', 'vk']
                for brand in brands:
                    if brand in extracted.subdomain and brand not in extracted.domain:
                        score -= 3
                        warnings.append(f"‚Ä¢ –ü–æ–¥–º–µ–Ω–∞ –±—Ä–µ–Ω–¥–∞ –≤ –ø–æ–¥–¥–æ–º–µ–Ω–µ: {brand}")
                        break

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Ü–∏—Ñ—Ä –≤–º–µ—Å—Ç–æ –±—É–∫–≤ (l33t speak)
            leet_patterns = [
                ('0', 'o'), ('1', 'l'), ('3', 'e'), ('4', 'a'),
                ('5', 's'), ('7', 't'), ('8', 'b'), ('9', 'g')
            ]

            leet_score = 0
            for num, letter in leet_patterns:
                if num in extracted.domain:
                    leet_score += 1

            if leet_score >= 2:
                score -= 2
                warnings.append("‚Ä¢ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ leet-speak (–ø–æ–¥–º–µ–Ω–∞ –±—É–∫–≤ —Ü–∏—Ñ—Ä–∞–º–∏)")

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥–µ—Ñ–∏—Å—ã
            hyphen_count = extracted.domain.count('-')
            if hyphen_count >= 2:
                score -= 1
                warnings.append(f"‚Ä¢ –ú–Ω–æ–≥–æ –¥–µ—Ñ–∏—Å–æ–≤: {hyphen_count}")

            score = max(0, min(score, 10))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º 0-10

            if score >= 8:
                status = '‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω—ã–π'
            elif score >= 6:
                status = '‚ö†Ô∏è –ü–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω—ã–π'
            elif score >= 3:
                status = '‚ùå –û–ø–∞—Å–Ω—ã–π'
            else:
                status = '‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π'

            details = '–ê–Ω–∞–ª–∏–∑ –Ω–∞ –ø—Ä–∏–∑–Ω–∞–∫–∏ —Ñ–∏—à–∏–Ω–≥–∞'
            if warnings:
                details += '\n' + '\n'.join(warnings[:4])

            return {'score': score, 'max_score': 10, 'status': status,
                    'details': details}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_for_phishing: {e}")
            return {'score': 7, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞ —Ñ–∏—à–∏–Ω–≥'}

    def check_site_structure(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å–∞–π—Ç–∞"""
        try:
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
            }

            response = requests.get(url, headers=headers, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')

            score = 8  # –ë–∞–∑–æ–≤—ã–π –±–∞–ª–ª
            details = []

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            nav_tags = soup.find_all(['nav', 'header', 'div.nav', 'div.menu', 'ul.menu'])
            if len(nav_tags) > 0:
                details.append("‚Ä¢ –ù–∞–≤–∏–≥–∞—Ü–∏—è: –µ—Å—Ç—å")
                score += 1
            else:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–∏—Å–∫–∏ –∫–∞–∫ –Ω–∞–≤–∏–≥–∞—Ü–∏—é
                ul_tags = soup.find_all('ul')
                has_nav = any(len(ul.find_all('li')) >= 3 for ul in ul_tags)
                if has_nav:
                    details.append("‚Ä¢ –ù–∞–≤–∏–≥–∞—Ü–∏—è: –ø—Ä–æ—Å—Ç–∞—è")
                else:
                    details.append("‚Ä¢ –ù–∞–≤–∏–≥–∞—Ü–∏—è: —Å–ª–∞–±–∞—è")
                    score -= 1

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
            h1_tags = soup.find_all('h1')
            if len(h1_tags) == 1:
                details.append("‚Ä¢ –ó–∞–≥–æ–ª–æ–≤–æ–∫ H1: –æ–¥–∏–Ω (–ø—Ä–∞–≤–∏–ª—å–Ω–æ)")
                score += 1
            elif len(h1_tags) == 0:
                details.append("‚Ä¢ –ó–∞–≥–æ–ª–æ–≤–æ–∫ H1: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
                score -= 1
            else:
                details.append(f"‚Ä¢ –ó–∞–≥–æ–ª–æ–≤–∫–æ–≤ H1: {len(h1_tags)} (–º–Ω–æ–≥–æ)")
                score -= 1

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ—É—Ç–µ—Ä–∞
            footer_tags = soup.find_all(['footer', 'div.footer', 'div#footer'])
            if len(footer_tags) > 0:
                details.append("‚Ä¢ –§—É—Ç–µ—Ä: –µ—Å—Ç—å")
                score += 1
            else:
                details.append("‚Ä¢ –§—É—Ç–µ—Ä: –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç")
                score -= 1

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –º–µ—Ç–∞-—Ç–µ–≥–æ–≤
            meta_tags = soup.find_all('meta')
            important_meta = ['description', 'keywords', 'viewport', 'author', 'robots']
            found_meta = 0

            for meta in meta_tags:
                if meta.get('name') in important_meta:
                    found_meta += 1

            if found_meta >= 3:
                details.append(f"‚Ä¢ –ú–µ—Ç–∞-—Ç–µ–≥–æ–≤: {found_meta}/5 (—Ö–æ—Ä–æ—à–æ)")
                score += 1
            elif found_meta >= 2:
                details.append(f"‚Ä¢ –ú–µ—Ç–∞-—Ç–µ–≥–æ–≤: {found_meta}/5 (–Ω–æ—Ä–º–∞–ª—å–Ω–æ)")
            else:
                details.append(f"‚Ä¢ –ú–µ—Ç–∞-—Ç–µ–≥–æ–≤: {found_meta}/5 (–º–∞–ª–æ)")
                score -= 1

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —è–∑—ã–∫–∞
            html_tag = soup.find('html')
            if html_tag and html_tag.get('lang'):
                details.append("‚Ä¢ –Ø–∑—ã–∫: —É–∫–∞–∑–∞–Ω")
                score += 1
            else:
                details.append("‚Ä¢ –Ø–∑—ã–∫: –Ω–µ —É–∫–∞–∑–∞–Ω")
                score -= 1

            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
            main_tags = soup.find_all(['main', 'div#content', 'div.content', 'article'])
            if len(main_tags) > 0:
                details.append("‚Ä¢ –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç: –≤—ã–¥–µ–ª–µ–Ω")
                score += 1

            score = max(5, min(score, 10))  # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º 5-10

            if score >= 8:
                status = '‚úÖ –•–æ—Ä–æ—à–∞—è'
            elif score >= 6:
                status = '‚ö†Ô∏è –°—Ä–µ–¥–Ω—è—è'
            else:
                status = '‚ùå –ü–ª–æ—Ö–∞—è'

            details_text = '\n'.join(details[:6])

            return {'score': score, 'max_score': 10, 'status': status,
                    'details': details_text}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_site_structure: {e}")
            return {'score': 6, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Å–∞–π—Ç–∞'}

    def check_redirects(self, url: str) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ HTTP —Ä–µ–¥–∏—Ä–µ–∫—Ç–æ–≤"""
        try:
            parsed = urlparse(url)

            # –ï—Å–ª–∏ URL —É–∂–µ HTTPS, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–¥–∏—Ä–µ–∫—Ç —Å HTTP
            if parsed.scheme == 'https':
                http_url = f"http://{parsed.netloc}"

                try:
                    response = requests.get(http_url, timeout=5, allow_redirects=True, verify=False)

                    if response.url.startswith('https://'):
                        return {'score': 10, 'max_score': 10, 'status': '‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω',
                                'details': '–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π —Ä–µ–¥–∏—Ä–µ–∫—Ç —Å HTTP –Ω–∞ HTTPS'}
                    elif response.status_code in [301, 302, 307, 308]:
                        return {'score': 7, 'max_score': 10, 'status': '‚ö†Ô∏è –ß–∞—Å—Ç–∏—á–Ω–æ',
                                'details': f'–†–µ–¥–∏—Ä–µ–∫—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω, –Ω–æ –Ω–µ –Ω–∞ HTTPS (–∫–æ–¥ {response.status_code})'}
                    else:
                        return {'score': 3, 'max_score': 10, 'status': '‚ùå –ù–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω',
                                'details': 'HTTP –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞–ø—Ä—è–º—É—é (–±–µ–∑ —Ä–µ–¥–∏—Ä–µ–∫—Ç–∞ –Ω–∞ HTTPS)'}
                except:
                    return {'score': 8, 'max_score': 10, 'status': '‚úÖ –ù–∞—Å—Ç—Ä–æ–µ–Ω',
                            'details': 'HTTP –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç (–≤–æ–∑–º–æ–∂–Ω–æ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞)'}
            else:
                # –ï—Å–ª–∏ URL HTTP, –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å HTTPS
                https_url = f"https://{parsed.netloc}"

                try:
                    response = requests.get(https_url, timeout=5, allow_redirects=False, verify=True)

                    if response.status_code == 200:
                        return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è HTTPS –¥–æ—Å—Ç—É–ø–µ–Ω',
                                'details': 'HTTPS —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ —Å–∞–π—Ç –∏—Å–ø–æ–ª—å–∑—É–µ—Ç HTTP'}
                    elif response.status_code in [301, 302]:
                        return {'score': 6, 'max_score': 10, 'status': '‚ö†Ô∏è –†–µ–¥–∏—Ä–µ–∫—Ç',
                                'details': f'HTTPS —Ä–µ–¥–∏—Ä–µ–∫—Ç–∏—Ç (–∫–æ–¥ {response.status_code})'}
                    else:
                        return {'score': 2, 'max_score': 10, 'status': '‚ùå HTTPS –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç',
                                'details': f'HTTPS –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω (–∫–æ–¥ {response.status_code})'}
                except requests.exceptions.SSLError:
                    return {'score': 1, 'max_score': 10, 'status': '‚ùå SSL –æ—à–∏–±–∫–∞',
                            'details': 'HTTPS –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ SSL'}
                except:
                    return {'score': 0, 'max_score': 10, 'status': '‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω',
                            'details': 'HTTPS –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç'}

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ check_redirects: {e}")
            return {'score': 5, 'max_score': 10, 'status': '‚ö†Ô∏è –ù–µ –ø—Ä–æ–≤–µ—Ä–µ–Ω–æ',
                    'details': '–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ä–µ–¥–∏—Ä–µ–∫—Ç—ã'}

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –±–æ—Ç–∞ (send_summary, results_handler –∏ —Ç.–¥.) –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    # –û–Ω–∏ —É–∂–µ –±—ã–ª–∏ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–º –∫–æ–¥–µ

    async def send_summary(self, update: Update, context: ContextTypes.DEFAULT_TYPE,
                           results: Dict, message_id: int = None):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —Å–≤–æ–¥–∫–∏ –∞–Ω–∞–ª–∏–∑–∞"""
        score = results['total_score']
        url = results['url']
        timestamp = results['timestamp']
        checks = results['checks']

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–≤–µ—Ç –∏ —É—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞
        if score >= 85:
            risk_text = "–û–ß–ï–ù–¨ –ù–ò–ó–ö–ò–ô"
            risk_emoji = "üü¢"
        elif score >= 70:
            risk_text = "–ù–ò–ó–ö–ò–ô"
            risk_emoji = "üü°"
        elif score >= 55:
            risk_text = "–°–†–ï–î–ù–ò–ô"
            risk_emoji = "üü†"
        elif score >= 40:
            risk_text = "–í–´–°–û–ö–ò–ô"
            risk_emoji = "üî¥"
        else:
            risk_text = "–û–ß–ï–ù–¨ –í–´–°–û–ö–ò–ô"
            risk_emoji = "‚õî"

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–≤–æ–¥–∫—É
        summary = (
            f"üìä *–°–í–û–î–ö–ê –ê–ù–ê–õ–ò–ó–ê*\n"
            f"{'=' * 30}\n\n"
            f"üåê *–°–∞–π—Ç:* `{url}`\n"
            f"‚è∞ *–í—Ä–µ–º—è:* {timestamp}\n"
            f"üèÜ *–û—Ü–µ–Ω–∫–∞:* *{score}/100* {risk_emoji}\n"
            f"‚ö†Ô∏è  *–£—Ä–æ–≤–µ–Ω—å —Ä–∏—Å–∫–∞:* {risk_text}\n\n"
        )

        # –ü—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä
        progress_length = 10
        filled = int(score / 100 * progress_length)
        progress_bar = "‚ñà" * filled + "‚ñë" * (progress_length - filled)

        summary += f"`{progress_bar} {score}%`\n\n"

        # –ö–ª—é—á–µ–≤—ã–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏
        security_score = sum(c['score'] for c in checks if c['category'] == 'security')
        security_max = sum(c['max_score'] for c in checks if c['category'] == 'security')

        auth_score = sum(c['score'] for c in checks if c['category'] == 'authenticity')
        auth_max = sum(c['max_score'] for c in checks if c['category'] == 'authenticity')

        perf_score = sum(c['score'] for c in checks if c['category'] == 'performance')
        perf_max = sum(c['max_score'] for c in checks if c['category'] == 'performance')

        quality_score = sum(c['score'] for c in checks if c['category'] == 'quality')
        quality_max = sum(c['max_score'] for c in checks if c['category'] == 'quality')

        summary += (
            f"üîê *–ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å:* {security_score}/{security_max}\n"
            f"üõ°Ô∏è  *–ê—É—Ç–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å:* {auth_score}/{auth_max}\n"
            f"‚ö° *–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:* {perf_score}/{perf_max}\n"
            f"üìä *–ö–∞—á–µ—Å—Ç–≤–æ:* {quality_score}/{quality_max}\n"
        )

        # –ö–Ω–æ–ø–∫–∏ –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
        keyboard = [
            [
                InlineKeyboardButton("üìã –î–µ—Ç–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã", callback_data="detailed_results"),
                InlineKeyboardButton("üí° –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", callback_data="recommendations")
            ],
            [
                InlineKeyboardButton("üîç –ù–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑", callback_data="analyze"),
                InlineKeyboardButton("üè† –í –º–µ–Ω—é", callback_data="back_to_menu")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # –†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
        if message_id:
            await context.bot.edit_message_text(
                chat_id=update.effective_chat.id,
                message_id=message_id,
                text=summary,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )
        else:
            await update.message.reply_text(
                summary,
                parse_mode='Markdown',
                reply_markup=reply_markup
            )

    async def results_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        query = update.callback_query
        await query.answer()

        if query.data == "detailed_results":
            await self.show_detailed_results(update, context)
            return DETAILS

        elif query.data == "recommendations":
            await self.show_recommendations(update, context)
            return RECOMMENDATIONS

        elif query.data == "analyze":
            await query.edit_message_text(
                "üåê *–í–≤–µ–¥–∏—Ç–µ URL —Å–∞–π—Ç–∞ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞:*\n\n"
                "–ü—Ä–∏–º–µ—Ä—ã:\n"
                "‚Ä¢ https://google.com\n"
                "‚Ä¢ youtube.com\n"
                "‚Ä¢ wikipedia.org\n\n"
                "–ù–∞–ø–∏—à–∏—Ç–µ URL –≤ —á–∞—Ç:",
                parse_mode='Markdown'
            )
            return URL_INPUT

        elif query.data == "back_to_menu":
            await self.start(update, context)
            return MENU

        elif query.data == "back_to_summary":
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–≤–æ–¥–∫–µ
            if 'last_results' in context.user_data:
                results = context.user_data['last_results']
                message_id = context.user_data.get('summary_message_id')

                # –ï—Å–ª–∏ –µ—Å—Ç—å ID —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Å–≤–æ–¥–∫–æ–π, —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º –µ–≥–æ
                if message_id:
                    try:
                        await self.send_summary(update, context, results, message_id)
                    except:
                        # –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–æ–≤–æ–µ
                        await self.send_summary(update, context, results)
                else:
                    await self.send_summary(update, context, results)

            return RESULTS

        return RESULTS

    async def show_detailed_results(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ç–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"""
        query = update.callback_query

        if 'last_results' not in context.user_data:
            await query.edit_message_text("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ —Å–Ω–∞—á–∞–ª–∞.")
            return

        results = context.user_data['last_results']
        checks = results['checks']

        detailed_text = "üìã *–î–ï–¢–ê–õ–¨–ù–´–ï –†–ï–ó–£–õ–¨–¢–ê–¢–´*\n"
        detailed_text += "=" * 40 + "\n\n"

        for check in checks:
            detailed_text += (
                f"*{check['name']}*\n"
                f"{check['status']} - {check['score']}/{check['max_score']}\n"
                f"{check['details']}\n\n"
            )

        # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞
        keyboard = [[InlineKeyboardButton("üîô –ö —Å–≤–æ–¥–∫–µ", callback_data="back_to_summary")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            detailed_text,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

    async def show_recommendations(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"""
        query = update.callback_query

        if 'last_results' not in context.user_data:
            await query.edit_message_text("‚ùå –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã. –í—ã–ø–æ–ª–Ω–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ —Å–Ω–∞—á–∞–ª–∞.")
            return

        results = context.user_data['last_results']
        score = results['total_score']

        recommendations = "üí° *–†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò*\n"
        recommendations += "=" * 40 + "\n\n"

        if score >= 85:
            recommendations += (
                "‚úÖ *–û–¢–õ–ò–ß–ù–ê–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨*\n\n"
                "*–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n"
                "‚Ä¢ –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å\n"
                "‚Ä¢ –†–µ–≥—É–ª—è—Ä–Ω–æ –æ–±–Ω–æ–≤–ª—è–π—Ç–µ SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç\n"
                "‚Ä¢ –ú–æ–Ω–∏—Ç–æ—Ä—å—Ç–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å\n"
                "‚Ä¢ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ HSTS –¥–ª—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ HTTPS\n"
            )
        elif score >= 70:
            recommendations += (
                "‚ö†Ô∏è  *–•–û–†–û–®–ê–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨*\n\n"
                "*–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n"
                "‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
                "‚Ä¢ –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ —Ä–µ–¥–∏—Ä–µ–∫—Ç–æ–≤\n"
                "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SSL\n"
                "‚Ä¢ –†–µ–≥—É–ª—è—Ä–Ω–æ –æ–±–Ω–æ–≤–ª—è–π—Ç–µ –ü–û —Å–∞–π—Ç–∞\n"
            )
        elif score >= 55:
            recommendations += (
                "‚ö†Ô∏è  *–°–†–ï–î–ù–Ø–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨*\n\n"
                "*–°–†–û–ß–ù–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:*\n"
                "‚Ä¢ –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ–π–¥–∏—Ç–µ –Ω–∞ HTTPS\n"
                "‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π—Ç–µ –±–∞–∑–æ–≤—ã–µ –∑–∞–≥–æ–ª–æ–≤–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
                "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ–º–µ–Ω –Ω–∞ –ª–µ–≥–∏—Ç–∏–º–Ω–æ—Å—Ç—å\n"
                "‚Ä¢ –ü—Ä–æ—Å–∫–∞–Ω–∏—Ä—É–π—Ç–µ —Å–∞–π—Ç –Ω–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏\n"
            )
        else:
            recommendations += (
                "‚ùå *–ù–ò–ó–ö–ê–Ø –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–¨*\n\n"
                "*–ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:*\n"
                "‚Ä¢ –ù–ï–ú–ï–î–õ–ï–ù–ù–û –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ HTTPS\n"
                "‚Ä¢ –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –¥–æ–º–µ–Ω –Ω–∞ —Ñ–∏—à–∏–Ω–≥\n"
                "‚Ä¢ –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Å–ø–µ—Ü–∏–∞–ª–∏—Å—Ç–∞–º –ø–æ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏\n"
                "‚Ä¢ –ù–µ –≤–≤–æ–¥–∏—Ç–µ –ª–∏—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —ç—Ç–æ–º —Å–∞–π—Ç–µ\n"
            )

        # –ö–Ω–æ–ø–∫–∞ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞
        keyboard = [[InlineKeyboardButton("üîô –ö —Å–≤–æ–¥–∫–µ", callback_data="back_to_summary")]]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            recommendations,
            parse_mode='Markdown',
            reply_markup=reply_markup
        )

    async def details_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π –≤ —Ä–µ–∂–∏–º–µ –¥–µ—Ç–∞–ª—å–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
        query = update.callback_query
        await query.answer()

        if query.data == "back_to_summary":
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–≤–æ–¥–∫–µ
            if 'last_results' in context.user_data:
                results = context.user_data['last_results']
                message_id = context.user_data.get('summary_message_id')

                if message_id:
                    try:
                        await self.send_summary(update, context, results, message_id)
                    except:
                        await self.send_summary(update, context, results)
                else:
                    await self.send_summary(update, context, results)

            return RESULTS

        return DETAILS

    async def recommendations_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–µ–π—Å—Ç–≤–∏–π –≤ —Ä–µ–∂–∏–º–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        query = update.callback_query
        await query.answer()

        if query.data == "back_to_summary":
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ —Å–≤–æ–¥–∫–µ
            if 'last_results' in context.user_data:
                results = context.user_data['last_results']
                message_id = context.user_data.get('summary_message_id')

                if message_id:
                    try:
                        await self.send_summary(update, context, results, message_id)
                    except:
                        await self.send_summary(update, context, results)
                else:
                    await self.send_summary(update, context, results)

            return RESULTS

        return RECOMMENDATIONS

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
        logger.error(f"Exception while handling an update: {context.error}")

        if update and hasattr(update, 'effective_chat'):
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text="‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."
            )

    def create_application(self) -> Application:
        """–°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è Telegram"""
        application = Application.builder().token(self.token).build()

        # –°–æ–∑–¥–∞–µ–º ConversationHandler —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º–∏ –ø–µ—Ä–µ—Ö–æ–¥–∞–º–∏
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler('start', self.start)],
            states={
                MENU: [
                    CallbackQueryHandler(self.menu_handler, pattern="^(analyze|example|help|back_to_menu)$")
                ],
                URL_INPUT: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.analyze_url)
                ],
                RESULTS: [
                    CallbackQueryHandler(
                        self.results_handler,
                        pattern="^(detailed_results|recommendations|analyze|back_to_menu|back_to_summary)$"
                    )
                ],
                DETAILS: [
                    CallbackQueryHandler(self.details_handler, pattern="^back_to_summary$")
                ],
                RECOMMENDATIONS: [
                    CallbackQueryHandler(self.recommendations_handler, pattern="^back_to_summary$")
                ]
            },
            fallbacks=[CommandHandler('start', self.start)],
            allow_reentry=True
        )

        application.add_handler(conv_handler)
        application.add_error_handler(self.error_handler)

        return application

    def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        application = self.create_application()

        print("=" * 60)
        print("üîê TELEGRAM –ë–û–¢: –ê–ù–ê–õ–ò–ó–ê–¢–û–† –ë–ï–ó–û–ü–ê–°–ù–û–°–¢–ò –°–ê–ô–¢–û–í")
        print("=" * 60)
        print("\nüì¶ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏:")
        print("pip install python-telegram-bot requests beautifulsoup4 tldextract dnspython")
        print("\n‚ö†Ô∏è  –í–ê–ñ–ù–û: –ó–∞–º–µ–Ω–∏—Ç–µ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –≤ –∫–æ–¥–µ!")

        application.run_polling(allowed_updates=Update.ALL_TYPES)


def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    # –ó–ê–ú–ï–ù–ò–¢–ï –≠–¢–û –ù–ê –í–ê–® –†–ï–ê–õ–¨–ù–´–ô –¢–û–ö–ï–ù!
    BOT_TOKEN = "–í–ê–® –¢–û–ö–ï–ù"

    if BOT_TOKEN == "–í–ê–® –¢–û–ö–ï–ù":
        print("\n‚ùå –û–®–ò–ë–ö–ê: –ó–∞–º–µ–Ω–∏—Ç–µ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞!")
        print("1. –û—Ç–∫—Ä–æ–π—Ç–µ Telegram ‚Üí @BotFather")
        print("2. /newbot ‚Üí –ø—Ä–∏–¥—É–º–∞–π—Ç–µ –∏–º—è ‚Üí username_bot")
        print("3. –°–∫–æ–ø–∏—Ä—É–π—Ç–µ —Ç–æ–∫–µ–Ω –≤–∏–¥–∞: 1234567890:ABCdefGHIjklMnOprstUVwxyz")
        print("4. –í—Å—Ç–∞–≤—å—Ç–µ –≤ –∫–æ–¥ –≤–º–µ—Å—Ç–æ '–í–ê–®_TELEGRAM_BOT_TOKEN_–ó–î–ï–°–¨'")

    bot = SecurityAnalyzerBot(BOT_TOKEN)
    bot.run()


if __name__ == "__main__":
    main()
